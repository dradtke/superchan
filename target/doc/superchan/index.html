<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `superchan` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, superchan">

    <title>superchan - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>superchan</a><wbr><a class='stability Experimental' title=''>Experimental</a></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/superchan/lib.rs.html#1-139'>[src]</a></span></h1>
<div class='docblock'>
<h1 id="superchan!" class='section-header'><a
                           href="#superchan!">Superchan!</a></h1>
<p>This crate provides a set of types that mimick Rust&#39;s native channels,
but which can be used to communicate over a network. For example, you may
have a <code>server.rs</code> that accepts incoming connections:</p>
<pre class='rust '>
<span class='comment'>// server.rs</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>receiver</span>: <span class='ident'>Receiver</span><span class='op'>&lt;</span>...<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>superchan</span>::<span class='ident'>TcpReceiver</span>::<span class='ident'>new</span>(<span class='comment'>/* ip address, e.g. &quot;127.0.0.1:8080&quot; */</span>);
<span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='ident'>receiver</span>.<span class='ident'>recv</span>();
<span class='comment'>// do something with `value`</span>
</pre>

<p>...and then send values to it from some <code>client.rs</code> running in a different process,
or even on a different computer:</p>
<pre class='rust '>
<span class='comment'>// client.rs</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sender</span>: <span class='ident'>Sender</span><span class='op'>&lt;</span>...<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>superchan</span>::<span class='ident'>TcpSender</span>::<span class='ident'>new</span>(<span class='comment'>/* ip address */</span>);
<span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> ...;
<span class='ident'>sender</span>.<span class='ident'>send</span>(<span class='ident'>value</span>);
</pre>

<p>The types used must be serializable and deserializable, so anything you send
must either natively support it, or derive <code>Encodable</code> and <code>Decodable</code>:</p>
<pre class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>serialize</span>;

<span class='attribute'>#[<span class='ident'>deriving</span>(<span class='ident'>Encodable</span>, <span class='ident'>Decodable</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Message</span> {
    ...
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>receiver</span>: <span class='ident'>Receiver</span><span class='op'>&lt;</span><span class='ident'>Message</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>superchan</span>::<span class='ident'>TcpReceiver</span>::<span class='ident'>new</span>(<span class='comment'>/* ip address */</span>);
    <span class='comment'>// now you can receive messages of type `Message`</span>
}
</pre>

<p>Naturally, if custom types are sent across the wire, then both the client and server
will need access to the type definition. Attempting to receive a value of a different
type than the one that was sent is unsupported, untested, and may even go as far as to
release the hounds.</p>

<h1 id="protocols" class='section-header'><a
                           href="#protocols">Protocols</a></h1>
<p>Right now the only supported protocol is TCP, but more will be added in the hopefully
not-too-distant future.</p>

<h1 id="formats" class='section-header'><a
                           href="#formats">Formats</a></h1>
<p>The Rust standard library currently only comes with one general-purpose serialization format,
which is JSON, so currently all implemented channels encode and decode their data
to and from JSON. Hopefully the advent of protocol buffers will eventually render this
unnecessary. =)</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use tcp::<a class='struct' href='../superchan/tcp/struct.TcpSender.html' title='superchan::tcp::TcpSender'>TcpSender</a>;</code></td></tr><tr><td><code>pub use tcp::<a class='struct' href='../superchan/tcp/struct.TcpReceiver.html' title='superchan::tcp::TcpReceiver'>TcpReceiver</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='tcp/index.html'
                               title='superchan::tcp'>tcp</a></td>
                        <td class='docblock short'><p>Module <code>tcp</code> provides support for channels that communicate
over TCP.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='enum' href='enum.ReceiverError.html'
                               title='superchan::ReceiverError'>ReceiverError</a></td>
                        <td class='docblock short'></td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Receiver.html'
                               title='superchan::Receiver'>Receiver</a></td>
                        <td class='docblock short'><p>Receiver is a generic trait for objects that are able to receive
values from across a network.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Sender.html'
                               title='superchan::Sender'>Sender</a></td>
                        <td class='docblock short'><p>Sender is a generic trait for objects that are able to send values
across a network.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "superchan";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>